<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Конспект по БД</title>
</head>
<body>
	<h2>Select</h2>
	<p>
		Первое чему стоит научиться в БД это делать выборку. Помогает в этом команда SELECT, в которой укакзывается какие именно поля мы хотим видеть на выходе. Но сама выборка не обходится одной лишь командой SELECT, чтобы добавить условий и сделать выборку точнее и более подходящей нашим желанием есть и другие команды, которые мы здесь рассмотрим.
	</p>
	
	<p>
		Но, обо всё по порядку. SELECT может доставать информацию как из одной таблицы, так и сразу из нескольких таблиц. Мы будем приводить примеры нашей выборке пока что на одной таблице. И таблица эта будет называться `earthquake`. Кстати привыкайти к таким странным ковычкам. Ставить их в названиях полей крайне важно.
	</p>
	
	<p>
		Наша табличка `earthquake` будет содержать 10 полей (столбцов) и выглядеть будет примерно так.
	</p>
	
	<table border="1">
		<caption>earthquake</caption>
		<tr>
			<th>earthquake_id</th>
			<th>occurred_on</th>
			<th>latitude</th>
			<th>longitude</th>
			<th>depth</th>
			<th>magnitude</th>
			<th>calculation_method</th>
			<th>network_id</th>
			<th>place</th>
			<th>cause</th>
		</tr>
		<tr>
			<td>1</td>
			<td>1969-01-01 9:07:06</td>
			<td>51.096</td>
			<td>-179.392</td>
			<td>45</td>
			<td>5.6</td>
			<td>mw</td>
			<td>iscgem812771</td>
			<td>Andreanof Islands, Aleutian Islands, Alaska</td>
			<td>earthquake</td>
		</tr>
		
		<tr>
			<td>...</td>
			<td>...</td>
			<td>...</td>
			<td>...</td>
			<td>...</td>
			<td>...</td>
			<td>...</td>
			<td>...</td>
			<td>...</td>
			<td>...</td>
		</tr>
		
		<tr>
			<td>23119</td>
			<td>2018-12-31 2:35:38</td>
			<td>54.4266</td>
			<td>-161.5131</td>
			<td>31</td>
			<td>6</td>
			<td>mww</td>
			<td>us2000izcv</td>
			<td>114km SE of Cold Bay, Alaska</td>
			<td>earthquake</td>
		</tr>
	</table>
	
	<p>
		Как понятно из таблички здесь будет содержаться информация о последних землетрясениях за 50 лет. И первичным ключом в этой таблице будет поле `earthquake_id`. Первичный ключ это что-то вроде статуса, который присуждается полю. Этот статус говорит о том, что значения этого поля всегда будут уникальны для каждой записи и никогда не будут повторяться. Чаще всего с первичным ключом делают поле ID и наш случай - не исключение. `earthquake_id` здесь играет поле айди, обозначая каждую запись порядковым номером.
	</p>
	
	<p>
		Поля `occurred_on`, `latitude`, `longitude` и `depth` содержат информацию о том, где и когда было землятрясение. Поле `calculation_method` показывает по какой формуле было посчитано поле `magnitude`. В поле `network_id` содержится инфа о том, какой терминал засёк землетрясение. А в полях `place` и `cause` указаным место и причина возникновения землятряса.
	</p>
	
	<p>
		Вроде со всеми полями разобрались, теперь приступим к практике выборки.
	</p>
	
	<h2>Первые выборки</h2>
	
	<p>
		Первым нашим запросом будет выборка всей информации из таблицы. Так мы сможем легко разобрать азы SELECT запросов. Чтобы выбрать всю информацию из таблицы, нам нужно сделать точный запрос, в котором мы укажем, какие поля мы хотим видеть (все), и из какой таблицы мы хотим видеть информацию. Указывать таблицу обязательно, даже если во всей базе данных у нас одна табилца. Вот собственно запрос <br>
		<pre>
			SELECT * FROM `earthquake`
		</pre>
		Здесь следует обратить внимание, что за чем идёт. Сначала мы пишем саму команду SELECT (выбери), затем указываем поля, которые хотим видеть (о звёздочки чуть позже), потом указываем команду FROM, после которой можно указать таблицы, к которым мы обращаемся, ну и в конце пишем само название таблицы. Язык очень просто читается, если перевести его на русский. "ВЫБЕРИ `поля` ИЗ `название_таблицы`<br>
		Теперь насчёт звёздочки. Так как нам нужны все-все поля, мы можем облегчить себе жизнь - не перечислять их все через запятую, а просто написать звёздочку (*). Это будет означать все-все-привсе поля.
	</p>
	
	<p>
		Чуть выше над результатом запроса мы видим, что было выведено 23119 записей. Немало, но есть и другой способ посчитать эти записи. С помощью функции COUNT. И выглядеть это будет вот так
		<pre>
			SELECT COUNT(*) FROM `earthquake`
		</pre>
		Таким образом резултатом будет именно это число: 23119. Функция COUNT подсчитывает количество записей в нашей выборке и в качестве её аргументов может быть указана как и звёздочка, что говорит "посчитай записи всех полей", так и название конкретного поля.
	</p>
	
	<h2>Оптимизация</h2>
	
	<p>
		Поговорим о такой немаловажной вещи в БД, как скорость исполнения запроса. Вызывая всю таблицу и выводя её какой-либо выборкой целиком мы нагружаем оперативную память компьютера. Если запрос исходит лишь от нас, то это нестрашно, но если нашей БД пользуются десятки тысяч человек, то это может иметь серьёзные последствия и стоить нам быстродействием исполнения наших программ. Так что следует обратить внимание на то, за какое время исполняется каждый запрос. Кстати говоря, предлагаю подвергнуть этому анализу наши предыдущие два примера. Первая выборка, где мы просто выводили всю таблицу целиком была исполнена за 78 милисекунд, тогда как запрос SELECT COUNT(*) был произведён в два раза быстрее, за 31 милисекунду.
	</p>
	<p>
		В следующей нашей выборке, мы будем более избирательны. Вместо того чтобы выбирать все поля, давайте выберем каких-нибудь три. Например occurred_on, magnitude и place. Вот таким образом
		<pre>SELECT `magnitude`, `place`, `occurred_on` FROM `earthquake`</pre>
		Тут мы можем менять порядок полей в результате как хотим. Сейчас у нас идёт поле magnitude, затем place, ну и последний - occurred_on. Прям в том же порядке, что и мы указали. Поменям порядок в запросе, мы и поменяем порядок вывода полей в результирующей таблице.
	</p>
	
	<h2>Условие WHERE</h2>
	
	<p>
		В случае, когда нам нужны какие-то конкретные данные из всей таблицы, например все землятрясения в Аляске, или все землятрясения с балом выше 6,4 баллов, мы используем условие WHERE. Другими словами, если с помощью SELECT мы конкретизируем поля, которые набираем, то с помощью SELECT мы конкретизируем записи, которые хотим видеть. Для примера давайте выведем записи о землятрясениях случившихся 1 января 2000 года или позже. Выводить будем все поля, но лишь те записи, которые будут удовлетворять нашим условиям <br>
		Итак, раз выводим все поля, значит пишем SELECT * Тут и думать нечего. Далее, из какой таблицы? Из earthquake конечно. Пишем FROM `earthquake`. Далее, указываем WHERE и после него пишем наше условие. Давайте ещё раз проговорим, какое у нас условие. Все землятрясения случившиеся 1 января 2000 года ИЛИ ПОЗЖЕ. Это значит, что дата происхождения может быть равна 2000-01-01 ИЛИ БОЛЬШЕ. Так и пишем:
		<pre>
			SELECT *
			FROM `earthquake`
			WHERE `occurred_on` >= '2000-01-01'
		</pre>
		Думаю указывать запросы таким образом удобнее. Итак в условии всё довольно логично. Поле occurred_on (напомню, что в нём у нас содержатся даты возникновения) должно быть больше или равно дате 2000-01-01. Почему именно такой формат даты? Потому что по всей таблицы именно такой и используется. Почему в ковычках? Условия всегда нужно указывать в ковычкаъ, чтобы SQL понимал, что это строка. Иначе он решит, что вы захотите вычесть из 2000 единицу два раза.
	</p>
	
	<p>
		Давайте ещё немного попрактикуемся в точной выборке. Выведем самое сильное землятрясение за 2010 год. Сила землятрясениия вычисляется в баллах, информация о которых содержится в поле magnitude. Но сначала определимся с условием даты. Нам нужен только 2010 год. Выходит нам нужны все даты больше 2010-01-01 И все даты меньше 2010-12-31. Легко:
		<pre>
			SELECT *
			FROM `earthquake`
			WHERE `occurred_on` >= '2010-01-01' AND `occurred_on` <= '2010-12-31'
		</pre>
		С помощью команды AND мы объединили наши два условия в одно. Но нам было показано целых 559 записей. Конечно же мы не будем в них копаться, смотря где самое большое значение поля `magnitude`. Для облегчения жизни мы можем дополнить наш запрос добавив ещё одну команду ORDER BY. Эта команда сортирует по указанному полю в порядку возрастания или убывания, в зависимости от того, как мы захотим. Пишется даже легче, чем условие WHERE. Сначала указываем команду ORDER BY, затем называем поле `magnitude`, затем просто пишем, отсортировать это поле по возростанию или по убыванию. Нам нужно самое большое значение magnitude, поэтому поставим его в начале, поэтому сортировка у нас будет по убыванию. По убыванию пишется вот так DESC, по возростанию вот так ASC. Ну а запрос будет выглядеть вот так:
		
		<pre>
			SELECT *
			FROM `earthquake`
			WHERE `occurred_on` >= '2010-01-01' AND `occurred_on` <= '2010-12-31'
			ORDER BY `magnitude` DESC
		</pre>
		
		И мы получаем таблицу с кучей записей, но первая запись в этой таблице, как раз то, что мы и искали!
		
		<table border="1">
		<tr>
			<th>earthquake_id</th>
			<th>occurred_on</th>
			<th>latitude</th>
			<th>longitude</th>
			<th>depth</th>
			<th>magnitude</th>
			<th>calculation_method</th>
			<th>network_id</th>
			<th>place</th>
			<th>cause</th>
		</tr>
		<tr>
			<td>18756</td>
			<td>2010-02-27 6:34:12</td>
			<td>-36.122</td>
			<td>-72.898</td>
			<td>22.9</td>
			<td>8.8</td>
			<td>mww</td>
			<td>official20100227063411530_30</td>
			<td>offshore Bio-Bio, Chile</td>
			<td>earthquake</td>
		</tr>
		<tr>
			<td>...</td>
			<td>...</td>
			<td>...</td>
			<td>...</td>
			<td>...</td>
			<td>...</td>
			<td>...</td>
			<td>...</td>
			<td>...</td>
			<td>...</td>
		</tr>
		<tr>
			<td>19222</td>
			<td>2010-12-30 12:02:42</td>
			<td>51.626</td>
			<td>177.378</td>
			<td>56.8</td>
			<td>5.5</td>
			<td>mwc</td>
			<td>usp000hsa4</td>
			<td>Rat Islands, Aleutian Islands, Alaska</td>
			<td>earthquake</td>
		</tr>
		</table>
		
		Опять же, не забываем про оптимизацию и про то, что мы хотели вывести всего одну запись, а вывели 559. Давайте же ещё дополним наш запрос, чтобы вывести только ту запись, которая нам нужна, ТОЛЬКо ПЕРВУЮ запись. Неволнуйтесь, тут непонадобится никаких условий, даже поля указывать не придётся. Мы буквально скажем БД вывести только одну запись с помощи команды LIMIT 1. После команды LIMIT на самом деле может стоять любая цифра, но в нашем случае там должна стоять единица. Попробуем:
		<pre>
			SELECT *
			FROM `earthquake`
			WHERE `occurred_on` >= '2010-01-01' AND `occurred_on` <= '2010-12-31'
			ORDER BY `magnitude` DESC
			LIMIT 1
		</pre>
		И получаем:
		<table border="1">
			<tr>
				<th>earthquake_id</th>
				<th>occurred_on</th>
				<th>latitude</th>
				<th>longitude</th>
				<th>depth</th>
				<th>magnitude</th>
				<th>calculation_method</th>
				<th>network_id</th>
				<th>place</th>
				<th>cause</th>
			</tr>
			<tr>
				<td>18756</td>
				<td>2010-02-27 6:34:12</td>
				<td>-36.122</td>
				<td>-72.898</td>
				<td>22.9</td>
				<td>8.8</td>
				<td>mww</td>
				<td>official20100227063411530_30</td>
				<td>offshore Bio-Bio, Chile</td>
				<td>earthquake</td>
			</tr>
		</table>
	</p>
	
	<p>
		Мы только что произвели чистый и эффективный запрос, который удовлетворяет все наши условия
	</p>
	
	<h2>Функции</h2>
	<p>
		Мы уже затронули одну из функций ранее - COUNT, которая подсчитывает количество записей в поле указанном в скобках этой функции. Также есть ещё немало полезных функций, но мы рассмотрим те, которые встречаются чаще всего. А именно:
		
		<ul>
			<li>COUNT</li>
			<li>MIN</li>
			<li>MAX</li>
			<li>AVG</li>
			<li>SUM</li>
		</ul>
	</p>
	
	<h3>MIN &amp; MAX</h3>
	
	<p>
		Разберём для начала функции MIN и MAX. С помощью этих функций мы можем выводить максимальные и минимальные значения поля указаных в скобках этих функций. Ещё разок, нам нужно максимальное значение поля. Что мы делаем? Мы прежде всего пишем SELECT и как и с функцией COUNT пишем нужную нам функцию рядом с SELECT, указывая в скобках нужное поле, вот так:
		<pre>
			SELECT MAX(`название поля`)
			FROM `earthquake`
		</pre>
		В итоге мы получим максимально значение этого поля из всей таблицы. Данная функция вывете лишь одну запись. Предлагаю вывести самое последние землятрясение в этой таблице. Другими словами нам нужна самая большая дата из поля `occurred_on`:
		
		<pre>
			SELECT MAX(`occurred_on`)
			FROM `earthquake`
		</pre>
		Получаем:
		<table border="1">
			<tr>
				<th>MAX( `occurred_on` )</th>
			</tr>
			<tr>
				<td>2018-12-31 2:35:38</td>
			</tr>
		</table>
		Из нашего запроса видно, что последнее землятрясение было 31 декабря 2012 года. Мы не устанавливали никаких условий и не лимитировали вывод нашей выборки. Сделали это гораздо проще, чем в предыдущих примеров с помощью функции MAX()
	</p>
	
	<p>
		Ещё один примерчик. Давайте выведем самое сильно землятрясение и самое слабое по шкале в поле `magnitude`. Пользоваться будем конечно функциями MIN И MAX:
	</p>
	
	<pre>
		SELECT MAX(`magnitude`), MIN(`magnitude`)
		FROM `earthquake`
	</pre>
	Вот результат:
	<table border="1">
		<tr>
			<th>MAX( `magnitude` )</th>
			<th>MIN( `magnitude` )</th>
		</tr>
		<tr>
			<td>9.1</td>
			<td>5.5</td>
		</tr>
	</table>
	
	<p>
		Остальные функции на разбор остаются в качетсве ДЗ, так как их синтаксис и принцип идентичен разобраным функциям. Для облегчения домашки скажу лишь, что функция AVG считает сраднее арифмитическое по всем значениям поля  в таблице, а SUM считает сумму значений по указанному полю.
	</p>
	
	<h3>DISTINCT</h3>
	
	<p>
		Для следующего примера будет нагляднее показать, чем объяснять. Давайте выведем причины землятресений, ну и чисто для наглядности их id. А конкретнее выведем такие поля, как `cause` и `earthquake_id`
		
		<pre>
			SELECT `earthquake_id`, `cause`
			FROM `earthquake`
		</pre>
		И тут мы сталкиваемся с проблемой, с вот таким выводом:
		<table border="1">
			<tr>
				<th>earthquake_id</th>
				<th>cause</th>
			</tr>
			<tr>
				<td>1</td>
				<td>earthquake</td>
			</tr>
			<tr>
				<td>2</td>
				<td>earthquake</td>
			</tr>
			<tr>
				<td>3</td>
				<td>earthquake</td>
			</tr>
			<tr>
				<td>4</td>
				<td>earthquake</td>
			</tr>
			<tr>
				<td>5</td>
				<td>earthquake</td>
			</tr>
			<tr>
				<td>6</td>
				<td>earthquake</td>
			</tr>
			<tr>
				<td>7</td>
				<td>earthquake</td>
			</tr>
			<tr>
				<td>8</td>
				<td>earthquake</td>
			</tr>
			<tr>
				<td>9</td>
				<td>earthquake</td>
			</tr>
			<tr>
				<td>10</td>
				<td>earthquake</td>
			</tr>
			<tr>
				<td>...</td>
				<td>...</td>
			</tr>
			<tr>
				<td>23119</td>
				<td>earthquake</td>
			</tr>
		</table>
	</p>
	
	<p>
		В чём проблема спросите вы. В том, что везде причина earthquake. Но я 100% знаю, что где-то там в таблице есть и другие значения этого поля. Но их не видно из-за огромного количества дубликатов. Что же делать? Нам поможет команда DISTINCT. Она также ставится в SELECT, но это не функция, поэтому скобки не нужны. Нужно лишь указать поле, в котором мы не хотим видеть повторяющиеся значения.
		
		<pre>
			SELECT DISTINCT `cause`
			FROM `earthquake`
		</pre>
		Получим вполне красивый ответ:
		<table border="1">
			<tr>
				<th>cause</th>
			</tr>
			<tr>
				<td>earthquake</td>
			</tr>
			<tr>
				<td>nuclear explosion</td>
			</tr>
			<tr>
				<td>explosion</td>
			</tr>
		</table>
		<br>
		Единственный нюанс, нам пришлось пожертвовать полем `earthquake_id`, так как команда DISTINCT может оперировать лишь с одним полем.
	</p>
	
	<p>
		Давайте же посчитаем количество землятресений вызванных различными причинами. Для начала посчитаем количество землятресений вызваных по естественным причинам. Для этого отлично подойдёт условие WHERE, а так как нам нужно именно посчитать, а не вывести записи, будем использовать функцию COUNT
		
		<pre>
			SELECT COUNT(*)
			FROM `earthquake`
			WHERE `cause` = 'earthquake'
		</pre>
		Наш результат: <b>22 942</b> случая. 
		<br>
		Теперь посчитаем количество случаев вызванных ядерным взрывом:
		<pre>
			SELECT COUNT(*)
			FROM `earthquake`
			WHERE `cause` = 'nuclear explosion'
		</pre>
		В данном случае мы получим <b>173</b> случая вызванных ядерным взрывом
		<br>
		Ну и последнее, сколько случаев в таблице, где указаная причина это просто взрыв
		<pre>
			SELECT COUNT(*)
			FROM `earthquake`
			WHERE `cause` = 'explosion'
		</pre>
		Ага, всего <b>4</b>. Чтож, не так уж много, можно посмотреть, что это за случаи. Для этого просто уберём функцию COUNT
		<pre>
			SELECT *
			FROM `earthquake`
			WHERE `cause` = 'explosion'
		</pre>
		<br>
		Ну и в итоге мы получим такую табличку
		
		<table border="1">
		<tr>
			<th>earthquake_id</th>
			<th>occurred_on</th>
			<th>latitude</th>
			<th>longitude</th>
			<th>depth</th>
			<th>magnitude</th>
			<th>calculation_method</th>
			<th>network_id</th>
			<th>place</th>
			<th>cause</th>
		</tr>
		<tr>
			<td>1483</td>
			<td>1973-02-16 5:02:58</td>
			<td>49.835</td>
			<td>78.232</td>
			<td>0</td>
			<td>5.6</td>
			<td>mb</td>
			<td>usp00000jc</td>
			<td>eastern Kazakhstan</td>
			<td>explosion</td>
		</tr>
		<tr>
			<td>2461</td>
			<td>1975-08-23 8:59:58</td>
			<td>73.369</td>
			<td>54.641</td>
			<td>0</td>
			<td>6.4</td>
			<td>mb</td>
			<td>usp0000cjx</td>
			<td>Novaya Zemlya, Russia</td>
			<td>explosion</td>
		</tr>
		<tr>
			<td>6107</td>
			<td>1984-11-02 20:44:59</td>
			<td>-21.883</td>
			<td>-138.994</td>
			<td>0</td>
			<td>5.7</td>
			<td>mb</td>
			<td>usp00028r7</td>
			<td>Tuamotu Archipelago, French Polynesia region</td>
			<td>explosion</td>
		</tr>
		<tr>
			<td>6380</td>
			<td>1985-05-08 20:27:59</td>
			<td>-21.823</td>
			<td>-139.048</td>
			<td>0</td>
			<td>5.7</td>
			<td>mb</td>
			<td>usp0002ejj</td>
			<td>Tuamotu Archipelago, French Polynesia region</td>
			<td>explosion</td>
		</tr>
		</table>
		
		Если погуглить, то можно заключить, что все эти землятрясения были вызваны не обычным взрывом, а тестированием того же ядерного оружия. На этом примере мы можем наблюдать довольно типичную проблему с БД - она не всегда идеальна. В причинах у этих 4-х записей должно было быть записано не просто взрыв, а ядерный взрыв.
	</p>
	
	<p>
		Давайте теперь подробнее рассмотрим случаи землятресений вызваных ядерным взрывом. Нам будет интересно место, количество баллов и дата события. А также давайте рассмотрим самое последнее событие. Соответсвенно этому наш запрос будет выглядеть вот так:
		<pre>
			SELECT `place`, `magnitude`, `occurred_on`
			FROM `earthquake`
			WHERE `cause` = 'nuclear explosion'
			ORDER BY `occurred_on` DESC
			LIMIT 1
		</pre>
		Отлично!
	</p>
	
	<p>
		Новая задача! Выведем топ 10 самых крупных землятресений в период с 1969 по 2018
		
		<pre>
			SELECT `place`, `magnitude`, `occurred_on`
			FROM `earthquake`
			ORDER BY `magnitude` DESC
			LIMIT 10
		</pre>
	</p>
	
	<p>
		Из результата мы видим, что довольно большое землятресение было в Японии. Интересно, как часто землятрясения там проходят. Чтобы выяснить это, мы можем вывести все записи, в которых в поле place есть такие слова как Japan и Honshu, которые прошли меньше чем через неделю от самого мощного. Соответственно нам нужны события между датами 2011-03-11 и плюс неделька = 2011-03-18. С датой мы ещё справиться сможем, уже делали это в условии WHERE. Но как искать записи по ключевым словам? Мы же не можем поставить `place` = 'Japan' AND `place` = 'Honshu'. SQL нас не поймёт, так как будет искать записи, где указаны лишь эти два слова, тогда как у нас места имеют более точное описание. <br>
		Так или иначе для этой задачи нам больше подойдёт команда LIKE которое поможет нам уточнить условие WHERE. Запрос будет выглядеть так:
		<pre>
			SELECT COUNT(*)
			FROM `earthquake`
			WHERE `place` LIKE '%Honshu%Japan%'
		</pre>
		
		Наш результат впечатляет: <b>765</b> Вас нверно интересуют знаки процента. Они ставятся чтобы дать SQL понять, что нас не интересует что идёт ДО и ПОСЛЕ слова Honshu => %Honshu%, а также что идёт ПОСЛЕ слова Japan => Japan%. Можно было бы указать, что нас также не интересует, что идёт до слова Japan, но в этом нет смысла, так как то, что идёт после слова Japan это то же самое, что и то, что идёт после слова Honshu. <br>
		Но в данно запросе ни слова о временном промежутке. А мы хотели сделать выборку за неделю, между датами 2011-03-11 и 2011-03-18. Понадобится второе условие. Чтобы объединять условия у нас есть ключевое слово AND. <br>
		Но позволю дать вам ещё один лайфхак. Вместо того, чтобы опять писать математические сравнения, предлагаю альтернативу - воспользоваться новой командой BETWEEN, которая покажет записи со значениями между определённых границ. Пишется это так:
		<pre>
			SELECT COUNT(*)
			FROM `earthquake`
			WHERE `place` LIKE '%Honshu%Japan%'
				AND `occurred_on` BETWEEN '2011-03-11' AND '2011-03-18'
		</pre>
		
		Воу, 166 случаев за неделю. Бедная Япония
	</p>
</body>
</html>