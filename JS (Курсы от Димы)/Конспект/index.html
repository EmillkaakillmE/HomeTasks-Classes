<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>JavaScript Основы для Начинающих - Полный Курс за 6 часов</title>
</head>
<body>
	<h2>Что такое JS</h2>
	
	<p>
		В 90ые, когда тырнет только начинал развиваться, не было никакого JS. Был лишь HTML и CSS. Но это было довольно скучно, не было никакого взаимодействия с пользователем (тогда не было CSS3 и ни о каких сложных анимациях и псевдо-классов кроме ховера речи и не шло). Поэтому было решено ввести ещё один язык - JavaScript. Ну точнее раньше он назывался LiveScript, был переименован с целью хайпануть на Java. Вот только Бил Гейтс заговнился и сказал, что у него будет свой JS с эксплоуреом и шлюзами. И тогда была сформирована типа комиссия под название EcmaScript. Которая следила за всеми изменениями клинтского языка программирования и была что-то типа стандарта который следли чтобы JavaScript был пригоден для всех браузеров
	</p>
	
	<p>
		В 2009 году Райан Даль изобрёл NodeJS. Суть его изобретения была в том, что он взял транскомпилятор браузер Хром и вытащил его наружу. Позволив JS работать вне браузера и дав возможность писать серверную часть на том же JS
	</p>
	
	<p>
		В 2015 году было последнее крупное обновление js в виде EcmaScript2015 (или ES6), которое влекло за собой появление какого-никакого ООП в языке, что очень сильно повлияло на язык, в хорошую сторону, конечно.
	</p>
	
	<p>
		Сейчас JS используется в куче индустрий, нетолько Фронтенд, но и Бэкент (благодаря NodeJS), мобайл и даже Десктоп апликэйшнс
	</p>
	
	<p>
		Как мы помним есть два основных способа прописывать скрипт. В теге &lt;script&rt;&lt;/script&rt; прямо в html коде. Или в отдельном файле и замет подключать этот файл через атрибут src="Путь к файлу". Но мы помним, что есть такой атрибут и его значение как type="text/javascript", которые уже необязательны в наше время. Его можно опустить.
	</p>
	
	
	<h2>Основы</h2>
	
	<h3>Создание переменных</h3>
	<p>
		Переменные это некоторые сущности, в которых мы можем хранить информацию и менять её. Создаются переменные с помощью ключевых слов. <br> Одно из таких слов - var (от англ variable). Далее мы называем переменную как хотим. Но в наше время ключевое слово var уже считается устаревшим, поэтому познакомимся же с другими <br>
		<br>
		Следующее ключевое слово - const (от англ constant). И ключевое слово let
		
		Отличие между var и let мы поймём позже. Зато сейчас сможем понять отличие let/var и const. Значения записаные в var и в let мы можем менять, переназначать. Те значения, что мы записали в const менять нельзя
	</p>
	
	<p>
		Перед разбором следующей темы сделаем небольшое отступление. В JS хорошим тоном считается создание переменных стилем camelCase. Очень часто придумывая имя переменной в одно слово уложиться трудно, чтобы описать даже вкратце, зачем нам эта переменная. А делать пробелы в JS запрещено. camelCase это стиль написания названий переменных, в котором первое слово начинается с маленькой буквы, а каждое последующе пишется слитно и начинается с большой буквы
	</p>
	
	
	<h3>Типы данных</h3>
	
	<p>
		В предыдущем примере мы уже рассмотрели такие типы данных ка number и string. Цифры и строки соответственно. Следующий тип данных - boolean, который принимает значения true/false. И уже сейчас стоит поговорить о динамической типизации для JS. в этом языке нет никакой пробелемы в том, что мы переопределеям переменные, независимо от их типа. Например была у меня переменна <code>let a = 10</code> <br>
		Её тип данных - number. Динамическая типизация нам легко позволяет взять и сделать вот так: <code>a = false</code>. То есть переопределить не просто значение переменно, а даже тип сменить. С number на boolean
	</p>
	
	<h4>Мутирование</h4>
	
	<p>
		Если мы хотим сложить строки (конкатенация) то для этого нам будет служить знак плюс. Складывание строку со строкой будет выглядеть так
		<pre>
			let string1 = "Hello ";
			let string2 = "World!";
			
			console.log(string1 + string2);
		</pre>
	</p>
	
	<p>
		Ничего необычного, за исключением плюса, который работает немного непривычно. Он просто сшивает строки в одну, можно привыкнуть. А что если сложить строку и цифру? Таким образом наша цифра мутирует в строку, поменяет тип данных. Это ещё одна особенность динамической типизации.
		<pre>
			let string1 = 'My age is ';
			let age = 22;
			
			console.log(string1 + age);		<!-- Выведется 'My age is 22'-->
		</pre>
	</p>
	
	<p>
		Но давайте пойдём ещё дальше. Попробуем предотвратить эти странные мувы со стороны JS и сделаем нашу цифру константой
		
		<pre>
			let string1 = 'My age is ';
			const age = 22;
			
			console.log(string1 + age);		<!-- Всё равно выведет 'My age is 22' -->
		</pre>
	</p>
	
	<p>
		Вот так поворот. Наша цифра всё равно мутировала в строку, даже когда была константой. Она ей и осталась, на самом деле - переопределить её попрежнему нельзя.
	</p>
	
	<p>
		Важная деталь. Такое мутирование не сделала нашу переменную строкой навсегда. Только на время конкатенации. После неё и до неё переменная остаётся с таким же типом данных, как мы и задумали. Фокус в том, что если JS видит, как к строке добавляется число, он автоматом приписывает к числу вот такую функцию
		
		<pre>
			console.log(string1 + age.toString());
		</pre>
	</p>
	
	<p>
		В зависимости от того где стоит инкремент, будет разное выполнение.
	</p>
	
	<script type="text/javascript">
		let num = 20;
		
		console.log(num++);	//Выведется 20
		console.log(num);		//Выведется 21
		
		console.log("");
	</script>
	
	<p>
		Если инкремент стоит справа от переменной, то он имеет низкий приоритет и выполняется не сразу после вызову. Поставив его слева мы это поменяем
		<script type="text/javascript">
		num = 20;
		
		console.log(++num);	//Выведется 20
		console.log(num);		//Выведется 21
		console.log("");
	</script>
	
	Тоже самое работае и для дикримента --.
	</p>
	
	
	<h3>Логические операторы</h3>
	
	<p>
		Мы с ними в принципе давно знакомы. И (&&), который выдаёт тру, только если все элементы логического выражение являются тру. Если же хоть один является фолс, то и значение всего выражения будет фолс. <br>
		Или (||) выдаёт тру, если хотя бы один элемент выражения является тру. Если же все элементы являются фолс, то и само выражение тоже будет фолс. <br>
		Ну и логическое НЕ (!). Просто меняет выражение в обратную сторону. Если выражение было тру, то станет фолс. Если было фолс, то станет тру. Эдакий тогл выражений
	</p>
	
	<p>
		Но примечательна здесь сама работы этих операторов. Если засовывать эти операторы в if, то исход будет ясен, там просто сравниваются значения, и если в итоге сравнения выводится тру, то выполняется код внутри if. Но что если мы будем использовать <strike>(наш мозг на 100%)</strike> эти операторы при создании переменной? Вот так:
		<pre>
			let a = 'Cat' || 'Dog'
		</pre>
		Что будет записано в переменную а? Выведя а в консоль мы увидим, что туда записался 'Cat'. Что ж, возможно записывается всегда первое значение. А если вот так:
		<pre>
			let a = false || true
		</pre>
		Выведется true. Значит берётся только трушное значение. Но в первом примере было 'Cat' и 'Dog', а вывелось только 'Cat'. Выходит что 'Cat' - у нас тру, а 'Dog' - false? Нет, это не так. 'Cat' и 'Dog' это две не пустые строки. С точки зрение приведения типов они оба принимают значение тру, так как любая не пустая строка выводит тру. Но почему же вывелся именно 'Cat'? А это уже особенность работы ||. Он проходится по всему выражению в поисках значения тру. И как только находит его останавливается и выводит его. Значит если мы запишем вот так:
		<pre>
			let a = false || 'Dog'
		</pre>
		То выведтся, конечно 'Dog'. <br>
		Но что если все значения в выражении будут приводится к фолс? Оператор || ничего не найдёт, что же он выдаст? Пройдя по всему выражению и не найдя ни одного тру, он выдаст последние значение в выражении. А значит из этого:
		<pre>
			let a = '' || 0
		</pre>
		Мы получим 0 выведя а. Напоминаю, что 0 и пустая строка приводятся к фолс <br>
		А как себя будет вести И (&&). С точностью да наоборот! Если || проходится по всему выражению в поисках значения тру и выводит его, то && рыщет по выражению в поисках фолс и выводит именно его. Но в чём-это эти операторы схожи - если они не находят свою жертву (тру у ||) и (фолс у &&), то они выводят последнее значение выражения <br>
		Давайте запихнём наш после
		<pre>
			
		</pre>
	</p>
</body>
</html>